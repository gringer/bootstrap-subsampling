#!/usr/bin/Rscript

## Author: David Eccles (gringer), 2008 <programming@gringer.org>

## gt2pw.r -- Calculate allele sharing values across all markers for all individuals in the input file

# usage: ./gt2pw.pl <input>
# where <input> is formatted as follows
# <marker>  aa aa ga ca ...

usage <- function(){
  cat("usage: ./gt2pw.r <simplegt file> [options]\n");
  cat("\nOther Options:\n");
  cat("-help               : Only display this help message\n");
  cat("-clustersize        : Number of parallel processes\n");
  cat("-usempi             : Use MPI for parallel cluster\n");
  cat("-makeimage          : Create an image after calculating matrix\n");
  cat("-dendrogram         : Create a sorted dendrogram after matrix\n");
  cat("\n");
}

loadData <- function(con, indivs, skip = 0, nlines = 1000){
  ## 1) Read in data
  gtData <- scan(con, skip = skip, what = character(), nlines =
                 nlines, quiet = TRUE);
  if(length(gtData)>0){
    ## 2) Extract markers
    markerNames <- gtData[0:(length(gtData)/(indivs+1) - 1) * (indivs+1) + 1];
    ## 3) Convert genotypes
    ## factor to make genotype substitutions easier
    gtData <-
    factor(gtData[-(0:(length(gtData)/(indivs+1) - 1) * (indivs+1) + 1)]);

    ## combine complementary genotypes
    ## 0: homozygous A/T
    ## 1: heterozygous A/T|C/G
    ## 2: homozygous C/G

    ## Aside: An alternative way to do this would be considering
    ## minor/major alleles. This would have benefits because the "D'-ish"
    ## distance calculation would be more accurate. However, determining
    ## the minor/major alleles per marker would take longer. The
    ## implementation of such a method would probably be something like
    ## subtracting the above values from 2 if the mean value exceeded 1,
    ## meaning you'd still lose out for genotypes with complementary
    ## alleles.
    ## 0: homozygous major allele
    ## 1: heterozygous major/minor
    ## 2: homozygous minor allele

    levels(gtData)[grep("([AT][AT])",levels(gtData))] <- 0;
    levels(gtData)[grep("([AT][CG]|[CG][AT])",levels(gtData))] <- 1;
    levels(gtData)[grep("([CG][CG])",levels(gtData))] <- 2;

    ## convert to numeric vector for easier dist calculations
    warnVal <- getOption("warn");
    options(warn = -1); # ignore NA conversion warning -- we want
                        # other values to be converted to NA
    gtData <- as.numeric(levels(gtData))[gtData];
    options(warn = warnVal);

    ## redim because factor/numeric conversion kills dimensions
    dim(gtData) <- c(indivs, length(gtData)/indivs);
    colnames(gtData) <- markerNames;
    if(indivLabels[1] != FALSE){
      rownames(gtData) <- indivLabels;
    }

    ## Note: a marker distance calculation similar to D' can be
    ## generated by substituting gtData with t(gtData) in the return
    ## value. Be aware that a ~500,000x500,000 matrix generated from
    ## that off the Affymetrix chip is *large*, and probably will
    ## cause R (and possibly the host computer) to freeze.
    cat("L", file=stderr());
    return(gtData);
  } else {
    return (integer());
  }
}

numClusters <- 2; # number of processors in the cluster
argLoc <- 1;      # any more than ~20, and R memory
inFile <- FALSE;  # limits will probably come into play
skipVal <- 0;
indSeq <- FALSE;
indivLabels <- FALSE;
numIndivs <- 0;
splitPoint <- FALSE;
useMPI <- FALSE; # use MPI for parallel interface
makeDendrogram <- FALSE; # If TRUE, make a sorted heatmap with dendrogram (slow)
makeImage <- FALSE; # Given that this generates a ~550MB PDF file for
                    # the T1D data, It's not a good idea to enable
                    # this for large input files

argLoc <- grep("--args",commandArgs()) + 1; # hack to get around R v2.4
                                            # issue stopping
                                            # commandArgs(TRUE) from
                                            # working
rVersion <- paste(R.Version()$major,substr(R.Version()$minor,1,1),sep=".")
cat("R Version: ", rVersion, "\n",
    file = stderr(), sep = "");


while(!is.na(commandArgs()[argLoc])){
  cat("Processing argument '", commandArgs()[argLoc], "'\n",
      file = stderr(), sep = "");
  if(file.exists(commandArgs()[argLoc])){ # file existence check
    if(inFile == FALSE){
      inFile <- gzfile(commandArgs()[argLoc]);
      ## check for header line
      z <- scan(inFile, nlines = 1, what = character(), quiet = TRUE);
      if((length(z) > 0) && (z[1] == "##")){
        indPos <- grep("IDs:",z);
        endPos <- grep(">",z);
        ## Determine individual labels
        ## This works even if more than one <ID> region is present in the
        ## header line, as might be the case in a 'join'ed file
        if(length(indPos) > 0){
          indSeq <- integer(0);
          indivLabels <- character(0);
          for(x in 1:length(indPos)){
            indSeq <- (indPos[x] + 1):(endPos[x] - 1);
            indivLabels <- c(indivLabels,z[indSeq]);
          }
          numIndivs <- length(indivLabels);
        }
        skipVal <- 1;
      } else {
        # header not included, so don't label individuals
        # an alternate decision would be to label them as 1:numIndivs
        numIndivs <- length(z) - 1;
        indivLabels <- FALSE;
      }
    } else{
      cat("Error: More than one input file specified\n", file = stderr());
      usage();
      quit(save = "no", status=1);
    }
  } else {
    if(commandArgs()[argLoc] == "-help"){
      usage();
      quit(save = "no", status=0);
    }
    if(commandArgs()[argLoc] == "-clustersize"){
      numClusters <- as.numeric(commandArgs()[argLoc + 1]);
      argLoc <- argLoc + 1;
    }
    if(commandArgs()[argLoc] == "-usempi"){
      useMPI <- TRUE;
    }
    if(commandArgs()[argLoc] == "-makeimage"){
      makeImage <- TRUE;
    }
    if(commandArgs()[argLoc] == "-dendrogram"){
      makeImage <- TRUE;
      makeDendrogram <- TRUE;
    }
  }
  argLoc <- argLoc + 1;
}

if(inFile == FALSE){
  cat("Error: No [valid] input file specified\n", file = stderr());
  usage();
  quit(save="no", status = 3);
}

## Extract genotype data, store in large array
open(inFile);
indDists <- 0;
## This section has been modified to (hopefully) work better in a
## computing cluster

## Package requirements... each version needs a different compile dir.
## If the package is not installed in R, this will try to compile it
## from a source file from a subdirectory ('Rlib/src') off the current
## directory.
if(!require(snow) && !require(snow, lib.loc =
                              paste("~/Rlib",rVersion,sep="/"))){
  install.packages("~/Rlib/src/snow_0.3-3.tar.gz",
                   lib=paste("~/Rlib",rVersion,sep="/"), repos=NULL);
  library(snow, lib.loc = paste("~/Rlib",rVersion,sep="/"));
}
if(useMPI){
  if(!require(Rmpi) && !require(Rmpi, lib.loc =
                                paste("~/Rlib",rVersion,sep="/"))){
    install.packages("~/Rlib/src/Rmpi_0.5-5.tar.gz",
                     lib=paste("~/Rlib",rVersion,sep="/"), repos=NULL);
    library(Rmpi, lib.loc = paste("~/Rlib",rVersion,sep="/"));
  }
}

cl <- NULL;
if(useMPI){
  cl <- getMPIcluster();
}
loadedCluster <- FALSE; # indicates that the cluster was [not] created in R
if(is.null(cl)){
  loadedCluster <- TRUE;
  cat("Creating", if(useMPI){"MPI"}, "cluster...", file = stderr());
  if(useMPI){
    cl <- makeMPIcluster(numClusters);
  } else {
    cl <- makeCluster(numClusters);
  }
  cat("done!\n", file = stderr());
}
cat("Loading genotype data:\n[one 'LD' pair per 1000 lines]\n", file=stderr());
numIterations <- 0;
numClusters <- length(cl);
retVal <- rep(list(c(NA,NA)),numClusters);
while(length(retVal[[numClusters]]) > 1){
  ## using replicate on master to (hopefully) avoid race conditions
  ## regarding file access
  retVal <- replicate(numClusters, loadData(inFile, indivs =
                      numIndivs, skip = skipVal), simplify = FALSE);
  ## Calculate distance matrix
  ## Note: this is what everything else was leading up to
  ## explanation of manhattan method from R help:
  ##  'manhattan': Absolute distance between the two vectors (1 norm).
  distRes <- clusterApply(cl, retVal, dist, method = "manhattan");
  for(repNum in 1:numClusters){
    if(length(retVal[[repNum]]) > 1){
      indDists <- indDists + distRes[[repNum]];
      cat("D", file=stderr());
    }
  }
  numIterations <- numIterations + 1;
}
close(inFile);
cat("\ndone!\n", file=stderr());
if(loadedCluster){
  cat("Stopping cluster...", file = stderr());
  stopCluster(cl);
  cat("done!\n", file = stderr());
}

write.csv(as.matrix(indDists));

if(makeImage){
  pdf("output_pwheatmap.pdf",width = 30, height = 30);
  indMat <- as.matrix(indDists);
  rm(indDists);
  diag(indMat) <- NA; ## ignore comparisons of individuals to themselves
  if(!makeDendrogram){
    image(1:numIndivs, 1:numIndivs, t(indMat)[ncol(indMat):1,], axes =
          FALSE, col = topo.colors(100), xlab = "", ylab = "");
    if(indivLabels[1] != FALSE){
      axis(1, 1:numIndivs, labels = indivLabels, las = 2, line = -0.5,
           tick = 0);
      axis(4, 1:numIndivs, labels = indivLabels, las = 2, line = -0.5,
           tick = 0);
    }
  } else {
    heatmap(indMat, col = topo.colors(100), symm = TRUE);
  }
  dummy <- dev.off();
}
